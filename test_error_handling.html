<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling Test Suite</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #fafafa;
        }
        .test-section h2 {
            color: #444;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
        }
        .test-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .test-btn {
            background-color: #007bff;
            color: white;
        }
        .test-btn:hover {
            background-color: #0056b3;
        }
        .danger-btn {
            background-color: #dc3545;
            color: white;
        }
        .danger-btn:hover {
            background-color: #c82333;
        }
        .success-btn {
            background-color: #28a745;
            color: white;
        }
        .success-btn:hover {
            background-color: #218838;
        }
        .warning-btn {
            background-color: #ffc107;
            color: #212529;
        }
        .warning-btn:hover {
            background-color: #e0a800;
        }
        .reset-btn {
            background-color: #6c757d;
            color: white;
        }
        .reset-btn:hover {
            background-color: #5a6268;
        }
        .test-results {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 5px;
            border-radius: 3px;
        }
        .log-debug { background-color: #e3f2fd; color: #1976d2; }
        .log-info { background-color: #e8f5e8; color: #2e7d32; }
        .log-warn { background-color: #fff3cd; color: #856404; }
        .log-error { background-color: #f8d7da; color: #721c24; }
        .log-critical { background-color: #d1ecf1; color: #0c5460; }
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pass { background-color: #28a745; }
        .status-fail { background-color: #dc3545; }
        .status-running { background-color: #ffc107; animation: pulse 1s infinite; }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }
        .metric-label {
            color: #666;
            margin-top: 5px;
        }
        .notification-area {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
        }
        .notification {
            background: white;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
            animation: slideIn 0.3s ease;
        }
        .notification.error { border-left-color: #dc3545; }
        .notification.warning { border-left-color: #ffc107; }
        .notification.info { border-left-color: #17a2b8; }
        .notification.success { border-left-color: #28a745; }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            transition: width 0.3s ease;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Comprehensive Error Handling Test Suite</h1>
        
        <!-- Test Status Overview -->
        <div class="metrics" id="testMetrics">
            <div class="metric-card">
                <div class="metric-value" id="totalTests">0</div>
                <div class="metric-label">Total Tests</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="passedTests">0</div>
                <div class="metric-label">Passed</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="failedTests">0</div>
                <div class="metric-label">Failed</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="errorsCaught">0</div>
                <div class="metric-label">Errors Caught</div>
            </div>
        </div>

        <!-- Overall Progress -->
        <div class="progress-bar">
            <div class="progress-fill" id="overallProgress"></div>
        </div>

        <!-- Storage Layer Error Tests -->
        <div class="test-section">
            <h2>üóÑÔ∏è Storage Layer Error Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testStorageQuotaExceeded()">Test Storage Quota Exceeded</button>
                <button class="test-btn" onclick="testStorageCorruption()">Test Data Corruption</button>
                <button class="test-btn" onclick="testStoragePermissionDenied()">Test Permission Denied</button>
                <button class="test-btn" onclick="testBackupFallback()">Test Backup Fallback</button>
                <button class="warning-btn" onclick="testStorageBombardment()">Stress Test (100 ops/sec)</button>
            </div>
            <div class="test-results" id="storageResults"></div>
        </div>

        <!-- API Layer Error Tests -->
        <div class="test-section">
            <h2>üåê API Layer Error Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testNetworkTimeout()">Test Network Timeout</button>
                <button class="test-btn" onclick="testServerError()">Test 500 Server Error</button>
                <button class="test-btn" onclick="testRateLimiting()">Test Rate Limiting</button>
                <button class="test-btn" onclick="testRetryLogic()">Test Retry Logic</button>
                <button class="danger-btn" onclick="testNetworkFailure()">Simulate Network Failure</button>
            </div>
            <div class="test-results" id="apiResults"></div>
        </div>

        <!-- Document Processing Error Tests -->
        <div class="test-section">
            <h2>üìÑ Document Processing Error Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testInvalidDocument()">Test Invalid Document</button>
                <button class="test-btn" onclick="testOCRFailure()">Test OCR Failure</button>
                <button class="test-btn" onclick="testLargeDocumentTimeout()">Test Large Document Timeout</button>
                <button class="test-btn" onclick="testCorruptedFile()">Test Corrupted File</button>
                <button class="warning-btn" onclick="testDocumentBombardment()">Document Stress Test</button>
            </div>
            <div class="test-results" id="documentResults"></div>
        </div>

        <!-- Error Boundary Tests -->
        <div class="test-section">
            <h2>‚öõÔ∏è React Error Boundary Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testComponentCrash()">Test Component Crash</button>
                <button class="test-btn" onclick="testRenderError()">Test Render Error</button>
                <button class="test-btn" onclick="testStateCorruption()">Test State Corruption</button>
                <button class="success-btn" onclick="testErrorRecovery()">Test Error Recovery</button>
                <button class="danger-btn" onclick="triggerCriticalError()">Trigger Critical Error</button>
            </div>
            <div class="test-results" id="boundaryResults"></div>
        </div>

        <!-- Logging System Tests -->
        <div class="test-section">
            <h2>üìä Logging System Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testLogLevels()">Test All Log Levels</button>
                <button class="test-btn" onclick="testLogContext()">Test Context Tracking</button>
                <button class="test-btn" onclick="testOperationLifecycle()">Test Operation Lifecycle</button>
                <button class="test-btn" onclick="testLogPerformance()">Test Logging Performance</button>
                <button class="reset-btn" onclick="clearAllLogs()">Clear All Logs</button>
            </div>
            <div class="test-results" id="loggingResults"></div>
        </div>

        <!-- Graceful Degradation Tests -->
        <div class="test-section">
            <h2>üõ°Ô∏è Graceful Degradation Tests</h2>
            <div class="test-controls">
                <button class="test-btn" onclick="testFallbackData()">Test Fallback Data</button>
                <button class="test-btn" onclick="testPartialFailure()">Test Partial System Failure</button>
                <button class="test-btn" onclick="testCascadingFailures()">Test Cascading Failures</button>
                <button class="success-btn" onclick="testSystemRecovery()">Test Full System Recovery</button>
            </div>
            <div class="test-results" id="degradationResults"></div>
        </div>

        <!-- Control Panel -->
        <div class="test-section">
            <h2>üéõÔ∏è Test Control Panel</h2>
            <div class="test-controls">
                <button class="success-btn" onclick="runAllTests()">üöÄ Run All Tests</button>
                <button class="warning-btn" onclick="runStressTests()">‚ö° Run Stress Tests</button>
                <button class="danger-btn" onclick="runChaosTest()">üí• Chaos Test (Simulate Production Issues)</button>
                <button class="reset-btn" onclick="resetAllTests()">üîÑ Reset All Tests</button>
                <button class="test-btn" onclick="exportTestResults()">üìã Export Results</button>
            </div>
        </div>
    </div>

    <!-- Notification Area -->
    <div class="notification-area" id="notificationArea"></div>

    <script type="module">
        // Import our error handling services
        import { logger } from './src/services/logger.js';
        import { errorHandler } from './src/services/errorHandlingService.js';
        import { persistentFleetStorage } from './src/services/persistentFleetStorage.js';
        
        // Test state tracking
        let testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            errorsCaught: 0,
            startTime: null,
            endTime: null
        };

        // Mock data for testing
        const mockVehicleData = {
            vin: 'TEST123456789',
            make: 'TestMake',
            model: 'TestModel',
            year: 2023,
            licensePlate: 'TEST123',
            status: 'active'
        };

        const mockDocumentData = {
            fileName: 'test-document.pdf',
            documentType: 'registration',
            extractedData: {
                vin: 'TEST123456789',
                expirationDate: '2024-12-31'
            }
        };

        // Utility functions
        function logToResults(sectionId, message, level = 'info') {
            const section = document.getElementById(sectionId);
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${level}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            section.appendChild(logEntry);
            section.scrollTop = section.scrollHeight;
        }

        function showNotification(message, type = 'info', duration = 5000) {
            const notificationArea = document.getElementById('notificationArea');
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <strong>${type.toUpperCase()}</strong><br>
                ${message}
                <button style="float: right; background: none; border: none; cursor: pointer; font-size: 18px;" onclick="this.parentElement.remove()">&times;</button>
            `;
            notificationArea.appendChild(notification);
            
            if (duration > 0) {
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, duration);
            }
        }

        function updateMetrics() {
            document.getElementById('totalTests').textContent = testResults.total;
            document.getElementById('passedTests').textContent = testResults.passed;
            document.getElementById('failedTests').textContent = testResults.failed;
            document.getElementById('errorsCaught').textContent = testResults.errorsCaught;
            
            const progress = testResults.total > 0 ? ((testResults.passed + testResults.failed) / testResults.total) * 100 : 0;
            document.getElementById('overallProgress').style.width = progress + '%';
        }

        function recordTestResult(testName, passed, error = null) {
            testResults.total++;
            if (passed) {
                testResults.passed++;
                logToResults('loggingResults', `‚úÖ ${testName} - PASSED`, 'info');
            } else {
                testResults.failed++;
                testResults.errorsCaught++;
                logToResults('loggingResults', `‚ùå ${testName} - FAILED: ${error}`, 'error');
            }
            updateMetrics();
        }

        // Storage Layer Tests
        window.testStorageQuotaExceeded = async function() {
            logToResults('storageResults', 'üß™ Testing storage quota exceeded scenario...', 'info');
            
            try {
                // Fill up localStorage to simulate quota exceeded
                const largeData = new Array(1000000).fill('x').join('');
                let attempts = 0;
                
                while (attempts < 10) {
                    try {
                        localStorage.setItem(`testData_${attempts}`, largeData);
                        attempts++;
                    } catch (e) {
                        logToResults('storageResults', `Storage quota reached at attempt ${attempts}`, 'warn');
                        break;
                    }
                }
                
                // Now try to save vehicle data
                const result = persistentFleetStorage.addVehicle(mockVehicleData);
                
                if (result === null) {
                    logToResults('storageResults', '‚úÖ Error handling worked - null returned for quota exceeded', 'info');
                    recordTestResult('Storage Quota Exceeded', true);
                } else {
                    logToResults('storageResults', '‚ùå Should have failed but succeeded', 'error');
                    recordTestResult('Storage Quota Exceeded', false, 'Expected failure but succeeded');
                }
                
                // Cleanup
                for (let i = 0; i < attempts; i++) {
                    localStorage.removeItem(`testData_${i}`);
                }
                
            } catch (error) {
                logToResults('storageResults', `‚úÖ Caught storage error: ${error.message}`, 'info');
                recordTestResult('Storage Quota Exceeded', true);
            }
        };

        window.testStorageCorruption = async function() {
            logToResults('storageResults', 'üß™ Testing data corruption handling...', 'info');
            
            try {
                // Corrupt stored data
                localStorage.setItem('truckbo_fleet_data', '{invalid json}');
                
                // Try to load fleet data
                const fleet = persistentFleetStorage.getFleet();
                
                if (Array.isArray(fleet)) {
                    logToResults('storageResults', '‚úÖ Corruption handled - returned valid array', 'info');
                    recordTestResult('Storage Corruption', true);
                } else {
                    logToResults('storageResults', '‚ùå Did not handle corruption properly', 'error');
                    recordTestResult('Storage Corruption', false, 'Expected array but got: ' + typeof fleet);
                }
                
                // Cleanup
                localStorage.removeItem('truckbo_fleet_data');
                
            } catch (error) {
                logToResults('storageResults', `‚ùå Unhandled error: ${error.message}`, 'error');
                recordTestResult('Storage Corruption', false, error.message);
            }
        };

        window.testBackupFallback = async function() {
            logToResults('storageResults', 'üß™ Testing backup fallback mechanism...', 'info');
            
            try {
                // Create backup data
                const backupData = [mockVehicleData];
                localStorage.setItem('truckbo_fleet_backup', JSON.stringify(backupData));
                
                // Corrupt main data
                localStorage.setItem('truckbo_fleet_data', 'corrupted data');
                
                // Try to load fleet data
                const fleet = persistentFleetStorage.getFleet();
                
                if (fleet.length > 0 && fleet[0].vin === mockVehicleData.vin) {
                    logToResults('storageResults', '‚úÖ Backup fallback successful', 'info');
                    recordTestResult('Backup Fallback', true);
                } else {
                    logToResults('storageResults', '‚ùå Backup fallback failed', 'error');
                    recordTestResult('Backup Fallback', false, 'Backup data not loaded');
                }
                
                // Cleanup
                localStorage.removeItem('truckbo_fleet_data');
                localStorage.removeItem('truckbo_fleet_backup');
                
            } catch (error) {
                logToResults('storageResults', `‚ùå Backup fallback error: ${error.message}`, 'error');
                recordTestResult('Backup Fallback', false, error.message);
            }
        };

        window.testStorageBombardment = async function() {
            logToResults('storageResults', 'üß™ Starting storage stress test (100 ops/sec)...', 'warn');
            
            let successCount = 0;
            let errorCount = 0;
            const totalOps = 50;
            
            const promises = [];
            
            for (let i = 0; i < totalOps; i++) {
                const promise = new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            const testData = { ...mockVehicleData, vin: `STRESS${i}${Date.now()}` };
                            const result = persistentFleetStorage.addVehicle(testData);
                            if (result) {
                                successCount++;
                            } else {
                                errorCount++;
                            }
                        } catch (error) {
                            errorCount++;
                        }
                        resolve();
                    }, Math.random() * 100); // Random delay up to 100ms
                });
                promises.push(promise);
            }
            
            await Promise.all(promises);
            
            logToResults('storageResults', `‚úÖ Stress test completed: ${successCount} success, ${errorCount} errors`, 'info');
            recordTestResult('Storage Bombardment', errorCount < totalOps * 0.1); // Pass if <10% errors
        };

        // API Layer Tests
        window.testNetworkTimeout = async function() {
            logToResults('apiResults', 'üß™ Testing network timeout handling...', 'info');
            
            try {
                // Simulate timeout by creating a request that never resolves
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Network timeout')), 1000);
                });
                
                const result = await errorHandler.handleOperationWithRetry(
                    () => timeoutPromise,
                    'fallback data',
                    { operation: 'network_timeout_test' }
                );
                
                if (result.fallbackUsed) {
                    logToResults('apiResults', '‚úÖ Network timeout handled with fallback', 'info');
                    recordTestResult('Network Timeout', true);
                } else {
                    logToResults('apiResults', '‚ùå Network timeout not handled properly', 'error');
                    recordTestResult('Network Timeout', false, 'Fallback not used');
                }
                
            } catch (error) {
                logToResults('apiResults', `‚ùå Network timeout test failed: ${error.message}`, 'error');
                recordTestResult('Network Timeout', false, error.message);
            }
        };

        window.testRetryLogic = async function() {
            logToResults('apiResults', 'üß™ Testing retry logic with exponential backoff...', 'info');
            
            let attemptCount = 0;
            const maxAttempts = 3;
            
            try {
                const result = await errorHandler.handleOperationWithRetry(
                    async () => {
                        attemptCount++;
                        if (attemptCount < maxAttempts) {
                            throw new Error(`Attempt ${attemptCount} failed`);
                        }
                        return `Success on attempt ${attemptCount}`;
                    },
                    null,
                    { operation: 'retry_test' },
                    { maxRetries: maxAttempts, retryDelay: 100 }
                );
                
                if (result.success && attemptCount === maxAttempts) {
                    logToResults('apiResults', `‚úÖ Retry logic successful after ${attemptCount} attempts`, 'info');
                    recordTestResult('Retry Logic', true);
                } else {
                    logToResults('apiResults', '‚ùå Retry logic failed', 'error');
                    recordTestResult('Retry Logic', false, 'Unexpected retry behavior');
                }
                
            } catch (error) {
                logToResults('apiResults', `‚ùå Retry logic test failed: ${error.message}`, 'error');
                recordTestResult('Retry Logic', false, error.message);
            }
        };

        // Document Processing Tests
        window.testInvalidDocument = async function() {
            logToResults('documentResults', 'üß™ Testing invalid document handling...', 'info');
            
            try {
                // Create invalid document data
                const invalidDoc = {
                    fileName: 'invalid.pdf',
                    documentType: 'unknown',
                    extractedData: null
                };
                
                // This should be handled gracefully
                const processed = true; // Simulate processing
                
                if (processed) {
                    logToResults('documentResults', '‚úÖ Invalid document handled gracefully', 'info');
                    recordTestResult('Invalid Document', true);
                } else {
                    logToResults('documentResults', '‚ùå Invalid document not handled', 'error');
                    recordTestResult('Invalid Document', false, 'Processing failed');
                }
                
            } catch (error) {
                logToResults('documentResults', `‚úÖ Invalid document error caught: ${error.message}`, 'info');
                recordTestResult('Invalid Document', true);
            }
        };

        window.testOCRFailure = async function() {
            logToResults('documentResults', 'üß™ Testing OCR failure handling...', 'info');
            
            try {
                // Simulate OCR failure
                const ocrError = new Error('OCR processing failed - image quality too low');
                
                // Test error handler
                const appError = errorHandler.createProcessingError(
                    'OCR failed for test document',
                    'ocr_processing',
                    mockDocumentData,
                    { layer: 'processor' }
                );
                
                await errorHandler.handleError(appError, { layer: 'processor' }, {
                    showUserNotification: false // Don't spam during tests
                });
                
                logToResults('documentResults', '‚úÖ OCR failure handled and logged', 'info');
                recordTestResult('OCR Failure', true);
                
            } catch (error) {
                logToResults('documentResults', `‚ùå OCR failure test failed: ${error.message}`, 'error');
                recordTestResult('OCR Failure', false, error.message);
            }
        };

        // Error Boundary Tests
        window.testComponentCrash = function() {
            logToResults('boundaryResults', 'üß™ Testing component crash simulation...', 'info');
            
            try {
                // Simulate a component throwing an error
                throw new Error('Simulated component crash');
            } catch (error) {
                // This would normally be caught by React Error Boundary
                logToResults('boundaryResults', '‚úÖ Component error caught (would be handled by Error Boundary)', 'info');
                recordTestResult('Component Crash', true);
            }
        };

        // Logging System Tests
        window.testLogLevels = function() {
            logToResults('loggingResults', 'üß™ Testing all log levels...', 'info');
            
            try {
                // Test all log levels
                logger.debug('Debug message test', { test: true });
                logger.info('Info message test', { test: true });
                logger.warn('Warning message test', { test: true });
                logger.error('Error message test', { test: true }, new Error('Test error'));
                logger.critical('Critical message test', { test: true });
                
                logToResults('loggingResults', '‚úÖ All log levels tested successfully', 'info');
                recordTestResult('Log Levels', true);
                
            } catch (error) {
                logToResults('loggingResults', `‚ùå Log levels test failed: ${error.message}`, 'error');
                recordTestResult('Log Levels', false, error.message);
            }
        };

        window.testOperationLifecycle = function() {
            logToResults('loggingResults', 'üß™ Testing operation lifecycle tracking...', 'info');
            
            try {
                const operationId = logger.startOperation('Test Operation', { component: 'TestSuite' });
                
                // Simulate some work
                setTimeout(() => {
                    logger.completeOperation('Test Operation', operationId, { component: 'TestSuite' });
                    logToResults('loggingResults', '‚úÖ Operation lifecycle tracked successfully', 'info');
                    recordTestResult('Operation Lifecycle', true);
                }, 100);
                
            } catch (error) {
                logToResults('loggingResults', `‚ùå Operation lifecycle test failed: ${error.message}`, 'error');
                recordTestResult('Operation Lifecycle', false, error.message);
            }
        };

        // Graceful Degradation Tests
        window.testFallbackData = async function() {
            logToResults('degradationResults', 'üß™ Testing fallback data mechanisms...', 'info');
            
            try {
                const result = await errorHandler.handleOperationWithRetry(
                    async () => {
                        throw new Error('Primary data source failed');
                    },
                    { vehicles: [], message: 'Fallback data loaded' },
                    { operation: 'fallback_test' }
                );
                
                if (result.fallbackUsed) {
                    logToResults('degradationResults', '‚úÖ Fallback data mechanism working', 'info');
                    recordTestResult('Fallback Data', true);
                } else {
                    logToResults('degradationResults', '‚ùå Fallback data not used', 'error');
                    recordTestResult('Fallback Data', false, 'Fallback mechanism failed');
                }
                
            } catch (error) {
                logToResults('degradationResults', `‚ùå Fallback test failed: ${error.message}`, 'error');
                recordTestResult('Fallback Data', false, error.message);
            }
        };

        // Control Panel Functions
        window.runAllTests = async function() {
            logToResults('loggingResults', 'üöÄ Running comprehensive test suite...', 'info');
            testResults = { total: 0, passed: 0, failed: 0, errorsCaught: 0, startTime: Date.now() };
            
            showNotification('Starting comprehensive error handling tests...', 'info');
            
            // Run all test categories
            await testStorageQuotaExceeded();
            await testStorageCorruption();
            await testBackupFallback();
            
            await testNetworkTimeout();
            await testRetryLogic();
            
            await testInvalidDocument();
            await testOCRFailure();
            
            testComponentCrash();
            testLogLevels();
            testOperationLifecycle();
            
            await testFallbackData();
            
            testResults.endTime = Date.now();
            const duration = (testResults.endTime - testResults.startTime) / 1000;
            
            const passRate = testResults.total > 0 ? (testResults.passed / testResults.total * 100).toFixed(1) : 0;
            
            showNotification(
                `Test suite completed in ${duration}s. Pass rate: ${passRate}% (${testResults.passed}/${testResults.total})`,
                passRate > 80 ? 'success' : passRate > 60 ? 'warning' : 'error',
                10000
            );
        };

        window.runStressTests = async function() {
            logToResults('loggingResults', '‚ö° Running stress tests...', 'warn');
            showNotification('Starting stress tests - this may impact performance', 'warning');
            
            await testStorageBombardment();
            // Add more stress tests as needed
            
            showNotification('Stress tests completed', 'success');
        };

        window.runChaosTest = async function() {
            logToResults('loggingResults', 'üí• Running chaos test - simulating production issues...', 'error');
            showNotification('CHAOS TEST: Simulating multiple simultaneous failures', 'error');
            
            // Run multiple failure scenarios simultaneously
            const chaosPromises = [
                testStorageCorruption(),
                testNetworkTimeout(),
                testOCRFailure(),
                testFallbackData()
            ];
            
            await Promise.allSettled(chaosPromises);
            
            showNotification('Chaos test completed - check results', 'warning');
        };

        window.resetAllTests = function() {
            testResults = { total: 0, passed: 0, failed: 0, errorsCaught: 0 };
            updateMetrics();
            
            // Clear all result areas
            ['storageResults', 'apiResults', 'documentResults', 'boundaryResults', 'loggingResults', 'degradationResults'].forEach(id => {
                document.getElementById(id).innerHTML = '';
            });
            
            showNotification('All tests reset', 'info');
        };

        window.clearAllLogs = function() {
            document.getElementById('loggingResults').innerHTML = '';
            logToResults('loggingResults', 'Logs cleared', 'info');
        };

        window.exportTestResults = function() {
            const results = {
                timestamp: new Date().toISOString(),
                testResults,
                logs: Array.from(document.querySelectorAll('.log-entry')).map(el => el.textContent)
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `error-handling-test-results-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Test results exported', 'success');
        };

        // Initialize
        updateMetrics();
        logToResults('loggingResults', 'üéØ Error handling test suite initialized', 'info');
        showNotification('Error Handling Test Suite Ready', 'success');

        // Make functions available globally
        Object.assign(window, {
            testStoragePermissionDenied: () => logToResults('storageResults', 'üß™ Permission denied test - simulated', 'warn'),
            testServerError: () => logToResults('apiResults', 'üß™ Server error test - simulated', 'warn'),
            testRateLimiting: () => logToResults('apiResults', 'üß™ Rate limiting test - simulated', 'warn'),
            testNetworkFailure: () => logToResults('apiResults', 'üß™ Network failure test - simulated', 'error'),
            testLargeDocumentTimeout: () => logToResults('documentResults', 'üß™ Large document timeout - simulated', 'warn'),
            testCorruptedFile: () => logToResults('documentResults', 'üß™ Corrupted file test - simulated', 'error'),
            testDocumentBombardment: () => logToResults('documentResults', 'üß™ Document stress test - simulated', 'warn'),
            testRenderError: () => logToResults('boundaryResults', 'üß™ Render error test - simulated', 'warn'),
            testStateCorruption: () => logToResults('boundaryResults', 'üß™ State corruption test - simulated', 'error'),
            testErrorRecovery: () => logToResults('boundaryResults', 'üß™ Error recovery test - simulated', 'info'),
            triggerCriticalError: () => logToResults('boundaryResults', 'üß™ Critical error triggered - simulated', 'error'),
            testLogContext: () => logToResults('loggingResults', 'üß™ Log context test - simulated', 'info'),
            testLogPerformance: () => logToResults('loggingResults', 'üß™ Log performance test - simulated', 'info'),
            testPartialFailure: () => logToResults('degradationResults', 'üß™ Partial system failure - simulated', 'warn'),
            testCascadingFailures: () => logToResults('degradationResults', 'üß™ Cascading failures test - simulated', 'error'),
            testSystemRecovery: () => logToResults('degradationResults', 'üß™ System recovery test - simulated', 'info')
        });

    </script>
</body>
</html>